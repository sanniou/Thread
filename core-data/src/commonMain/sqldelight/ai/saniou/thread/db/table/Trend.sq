import kotlin.Boolean;

CREATE TABLE Trend (
    id TEXT NOT NULL PRIMARY KEY,
    sourceId TEXT NOT NULL,
    tabId TEXT NOT NULL,
    topicId TEXT NOT NULL,
    date TEXT NOT NULL,
    rank INTEGER NOT NULL,
    page INTEGER NOT NULL,

    -- Metadata only
    hotness TEXT,
    isNew INTEGER AS Boolean NOT NULL DEFAULT 0,
    payload TEXT,

    publishDate INTEGER,
    updateDate INTEGER,
    receiveDate INTEGER NOT NULL,
    FOREIGN KEY (sourceId, topicId) REFERENCES Topic(sourceId, id) ON DELETE CASCADE
);

CREATE INDEX idx_trend_query ON Trend(sourceId, tabId, date, page, rank);
CREATE INDEX idx_trend_realtime ON Trend(sourceId, tabId, receiveDate);

upsert:
INSERT INTO Trend(id, sourceId, tabId, topicId, date, rank, page, hotness, isNew, payload, publishDate, updateDate, receiveDate)
VALUES ?
ON CONFLICT(id) DO UPDATE SET
    sourceId = excluded.sourceId,
    tabId = excluded.tabId,
    topicId = excluded.topicId,
    date = excluded.date,
    rank = excluded.rank,
    page = excluded.page,
    hotness = excluded.hotness,
    isNew = excluded.isNew,
    payload = excluded.payload,
    publishDate = excluded.publishDate,
    updateDate = excluded.updateDate,
    receiveDate = excluded.receiveDate;

countTrends:
SELECT count(*) FROM Trend WHERE sourceId = :sourceId AND tabId = :tabId AND date = :date;

-- 定义一个视图，包含所有复杂的计算字段
CREATE VIEW TrendDetailView AS
SELECT
    Trend.id,
    Trend.sourceId,
    Trend.tabId,
    Trend.topicId,
    Trend.date,
    Trend.rank,
    Trend.page,
    Topic.title AS title,
    Topic.summary AS contentPreview,
    Trend.hotness,
    Channel.name AS channel,
    Topic.authorName AS author,
    Trend.isNew,
    Trend.payload,
    Trend.publishDate,
    Trend.updateDate,
    Trend.receiveDate
FROM Trend
LEFT JOIN Topic ON Trend.sourceId = Topic.sourceId AND Trend.topicId = Topic.id
LEFT JOIN Channel ON Topic.sourceId = Channel.sourceId AND Topic.channelId = Channel.id;

-- 查询 1：使用 Keyser Paging (基于 Rank)
getTrendsKeyset:
SELECT *
FROM TrendDetailView
WHERE sourceId = :sourceId
  AND tabId = :tabId
  AND date = :date
ORDER BY rank ASC
LIMIT :limit OFFSET :offset;

-- 查询 2：使用 Keyset Paging (基于 ReceiveDate)
getRealtimeTrendsKeyset:
SELECT *
FROM TrendDetailView
WHERE sourceId = :sourceId
  AND tabId = :tabId
ORDER BY receiveDate DESC
LIMIT :limit OFFSET :offset;

deleteTrendsByTabAndDate:
DELETE FROM Trend WHERE sourceId = :sourceId AND tabId = :tabId AND date = :date;

deleteTrendsByTabDateAndPage:
DELETE FROM Trend WHERE sourceId = :sourceId AND tabId = :tabId AND date = :date AND page = :page;
