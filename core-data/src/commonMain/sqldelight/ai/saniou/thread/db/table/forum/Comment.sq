import kotlin.Boolean;

-- 创建 Comment 表
CREATE TABLE IF NOT EXISTS Comment (
    id TEXT NOT NULL,
    sourceId TEXT NOT NULL,
    topicId TEXT NOT NULL,
    page INTEGER NOT NULL,
    userHash TEXT NOT NULL,
    admin INTEGER NOT NULL,
    title TEXT, -- 可为空
    createdAt INTEGER NOT NULL,
    content TEXT NOT NULL,
    authorName TEXT NOT NULL,
    floor INTEGER NOT NULL ,
    replyToId TEXT,
    agreeCount INTEGER,
    disagreeCount INTEGER,
    subCommentCount INTEGER NOT NULL DEFAULT 0,
    authorLevel INTEGER,
    isPo INTEGER AS Boolean NOT NULL DEFAULT 0,
    PRIMARY KEY (sourceId, id),
    FOREIGN KEY (sourceId, topicId) REFERENCES Topic(sourceId, id) ON DELETE CASCADE
);

-- 索引迁移
CREATE INDEX IF NOT EXISTS idx_comment_topic_id ON Comment(sourceId, topicId);

-- 2. 评论列表关联表：存储分页和排序关系
-- 支持多种视图模式：all(全部), po(楼主), reply(回复), 以及未来可能的其他模式
CREATE TABLE CommentListing (
    sourceId TEXT NOT NULL,
    commentId TEXT NOT NULL,
    topicId TEXT NOT NULL,
    
    -- 视图模式标识
    viewMode TEXT NOT NULL,  -- 枚举: "all", "po", "reply" 等
    
    -- 分页信息
    page INTEGER NOT NULL DEFAULT 0,  -- 页码（用于API分页）
    receiveDate INTEGER NOT NULL DEFAULT 0,  -- 本地接收时间，用于缓存版本控制
    receiveOrder INTEGER NOT NULL DEFAULT 0,  -- 本地接收顺序，用于Keyset分页
    
    PRIMARY KEY (sourceId, commentId, topicId, viewMode),
    FOREIGN KEY (sourceId, commentId) REFERENCES Comment(sourceId, id) ON DELETE CASCADE,
    FOREIGN KEY (sourceId, topicId) REFERENCES Topic(sourceId, id) ON DELETE CASCADE
);

-- 索引：用于快速查询某topic某模式下的评论
CREATE INDEX IF NOT EXISTS idx_comment_listing_query ON CommentListing(sourceId, topicId, viewMode, page);
CREATE INDEX IF NOT EXISTS idx_comment_listing_receive ON CommentListing(sourceId, topicId, viewMode, receiveDate);
CREATE INDEX IF NOT EXISTS idx_comment_listing_order ON CommentListing(sourceId, topicId, viewMode, receiveOrder);

-- 插入 Comment 数据
upsertComment:
INSERT INTO Comment (
    id, sourceId, topicId, page, userHash, admin, title, createdAt, content, authorName, floor, replyToId,
    agreeCount, disagreeCount, subCommentCount, authorLevel, isPo
) VALUES ?
ON CONFLICT(sourceId, id) DO UPDATE SET
    topicId = excluded.topicId,
    page = CASE WHEN excluded.page >= 0 THEN excluded.page ELSE Comment.page END,
    userHash = excluded.userHash,
    admin = excluded.admin,
    title = excluded.title,
    createdAt = excluded.createdAt,
    content = excluded.content,
    authorName = excluded.authorName,
    floor = excluded.floor,
    replyToId = excluded.replyToId,
    agreeCount = excluded.agreeCount,
    disagreeCount = excluded.disagreeCount,
    subCommentCount = excluded.subCommentCount,
    authorLevel = excluded.authorLevel,
    isPo = excluded.isPo;

-- 删除 Comment 数据
deleteComment:
DELETE FROM Comment WHERE sourceId = ? AND id = ?;

-- 删除指定 topicId 的 Comment 数据
deleteCommentsByTopicId:
DELETE FROM Comment WHERE sourceId = ? AND topicId = ?;

-- 获取指定 id 的 Comment
getCommentById:
SELECT * FROM Comment WHERE sourceId = :sourceId AND id = :id;

-- 获取指定 topicId 的最后五条回复
getLastFiveComments:
SELECT * FROM Comment WHERE sourceId = :sourceId AND topicId = :topicId AND (floor != 1 || floor ISNULL ) ORDER BY createdAt DESC LIMIT 5;

countCommentsByTopicIdAndFloor:
SELECT count(1) FROM Comment WHERE sourceId = :sourceId AND topicId = :topicId AND floor >= :floor LIMIT 1;


-- PagingSource (所有回复)
countCommentsByTopicId:
SELECT count(1) FROM Comment WHERE sourceId = :sourceId AND topicId = :topicId AND floor >= 0;

-- PagingSource (PO Mode using JOIN)
countCommentsByTopicIdPoMode:
SELECT count(1)
FROM Comment
JOIN Topic ON Comment.sourceId = Topic.sourceId AND Comment.topicId = Topic.id
WHERE Comment.sourceId = :sourceId
  AND Comment.topicId = :topicId
  AND Comment.userHash = Topic.authorId
  AND Comment.floor >= 0
  ;

countCommentsByTopicIdPoModeAndFloor:
SELECT count(1)
FROM Comment
JOIN Topic ON Comment.sourceId = Topic.sourceId AND Comment.topicId = Topic.id
WHERE Comment.sourceId = :sourceId
  AND Comment.topicId = :topicId
  AND Comment.userHash = Topic.authorId
  AND Comment.floor >= :floor
LIMIT 1;

getCommentsKeyset:
SELECT * FROM Comment
WHERE sourceId = :sourceId
  AND topicId = :topicId
  AND floor >= 0
ORDER BY floor ASC
LIMIT :limit OFFSET :offset;

getCommentsPoModeKeyset:
SELECT Comment.*
FROM Comment
JOIN Topic ON Comment.sourceId = Topic.sourceId AND Comment.topicId = Topic.id
WHERE Comment.sourceId = :sourceId
  AND Comment.topicId = :topicId
  AND Comment.userHash = Topic.authorId
  AND Comment.floor >= 0
ORDER BY Comment.floor ASC
LIMIT :limit OFFSET :offset;

searchComments:
SELECT * FROM Comment
WHERE (content LIKE ('%' || :query || '%') OR title LIKE ('%' || :query || '%'))
AND page >= 0
ORDER BY createdAt DESC
LIMIT :limit OFFSET :offset;

countSearchComments:
SELECT count(*) FROM Comment
WHERE (content LIKE ('%' || :query || '%') OR title LIKE ('%' || :query || '%'))
AND page >= 0;

getCommentsByUserHashOffset:
SELECT * FROM Comment WHERE userHash = :userHash  AND page >= 0 ORDER BY createdAt DESC LIMIT :limit OFFSET :offset;

countCommentsByUserHashNoTopic:
SELECT count(*) FROM Comment WHERE userHash = :userHash  AND page >= 0;

-- 根据日期范围查找回复 (用于 Trend 缓存)
getCommentByTopicIdAndDateRange:
SELECT * FROM Comment WHERE sourceId = :sourceId AND topicId = :topicId AND createdAt >= :start AND createdAt < :end ORDER BY id ASC LIMIT 1;

getAllCommentsByTopicId:
SELECT * FROM Comment WHERE sourceId = :sourceId AND topicId = :topicId AND page >= 0 ORDER BY id ASC;

getAllCommentsByTopicIdPoMode:
SELECT Comment.*
FROM Comment
JOIN Topic ON Comment.sourceId = Topic.sourceId AND Comment.topicId = Topic.id
WHERE Comment.sourceId = :sourceId
  AND Comment.topicId = :topicId
  AND Comment.userHash = Topic.authorId
ORDER BY Comment.id ASC;

getCommentsByTopicIdPoMode:
SELECT Comment.*
FROM Comment
JOIN Topic ON Comment.sourceId = Topic.sourceId AND Comment.topicId = Topic.id
WHERE Comment.sourceId = :sourceId
  AND Comment.topicId = :topicId
  AND Comment.userHash = Topic.authorId
  AND Comment.page = :page
ORDER BY Comment.id ASC;

-- CommentListing 相关查询

-- 插入或更新 CommentListing
upsertCommentListing:
INSERT INTO CommentListing (
    sourceId, commentId, topicId, viewMode, page, receiveDate, receiveOrder
) VALUES ?
ON CONFLICT (sourceId, commentId, topicId, viewMode) DO UPDATE SET
    page = excluded.page,
    receiveDate = excluded.receiveDate,
    receiveOrder = excluded.receiveOrder;

-- 删除指定 topicId 和 viewMode 的 CommentListing
deleteCommentListingsByTopicIdAndViewMode:
DELETE FROM CommentListing WHERE sourceId = :sourceId AND topicId = :topicId AND viewMode = :viewMode;

-- 检查指定 topicId、viewMode 和 page 是否存在 CommentListing（用于 cacheChecker）
hasCommentListingForPage:
SELECT EXISTS(
    SELECT 1 FROM CommentListing
    WHERE sourceId = :sourceId
      AND topicId = :topicId
      AND viewMode = :viewMode
      AND page = :page
) AS hasListing;

-- 获取指定 topicId 和 viewMode 的最大 receiveDate
getMaxReceiveDateByTopicAndViewMode:
SELECT MAX(receiveDate) FROM CommentListing WHERE sourceId = :sourceId AND topicId = :topicId AND viewMode = :viewMode;

-- PagingSource: 统计评论数量（全部模式）
countCommentsByTopicIdAndViewMode:
SELECT count(*) FROM CommentListing
WHERE sourceId = :sourceId
  AND topicId = :topicId
  AND viewMode = :viewMode
  AND (
      (:isFallback = 1)
      OR
      (receiveDate = (SELECT MAX(receiveDate) FROM CommentListing WHERE sourceId = :sourceId AND topicId = :topicId AND viewMode = :viewMode))
  );

-- PagingSource: 查询评论（全部模式，带 receiveDate 和 receiveOrder）
getCommentsByTopicIdAndViewModeKeyset:
SELECT Comment.*, CommentListing.receiveDate, CommentListing.receiveOrder
FROM Comment
JOIN CommentListing ON Comment.sourceId = CommentListing.sourceId AND Comment.id = CommentListing.commentId
WHERE CommentListing.sourceId = :sourceId
  AND CommentListing.topicId = :topicId
  AND CommentListing.viewMode = :viewMode
  AND (
      (:isFallback = 1)
      OR
      (CommentListing.receiveDate = (SELECT MAX(receiveDate) FROM CommentListing WHERE sourceId = :sourceId AND topicId = :topicId AND viewMode = :viewMode))
  )
ORDER BY CommentListing.receiveOrder ASC, CommentListing.commentId DESC
LIMIT :limit OFFSET :offset;
