import kotlin.Boolean;

-- 创建 Topic 表
CREATE TABLE IF NOT EXISTS Topic (
    id TEXT NOT NULL,
    sourceId TEXT NOT NULL,
    channelId TEXT NOT NULL,
    commentCount INTEGER NOT NULL,
    authorId TEXT NOT NULL,
    authorName TEXT NOT NULL,
    title TEXT, -- 可为空
    content TEXT, -- 详情页 HTML 内容，可能为空 (列表页不返回)
    summary TEXT, -- 列表页摘要，可能为空
    agreeCount INTEGER ,
    disagreeCount INTEGER ,
    isCollected INTEGER AS Boolean ,
    createdAt INTEGER NOT NULL,
    lastReplyAt INTEGER NOT NULL DEFAULT 0, -- 列表页最新评论时间戳 用来排序数据库 topic
    lastVisitedAt INTEGER,
    lastViewedCommentId TEXT,
    PRIMARY KEY (sourceId, id)
);

-- 2. 列表关联表：存储排序关系
-- 联合主键确保：同一个 Topic 在 同一个列表 中只能出现一次
CREATE TABLE TopicListing (
    sourceId TEXT NOT NULL,
    topicId TEXT NOT NULL,

    -- 列表标识
    listType TEXT NOT NULL, -- 枚举: "timeline", "trend", "channel"
    listId TEXT NOT NULL,   -- 具体ID: "main", "daily", "12345"

    page INTEGER NOT NULL DEFAULT 0,
    receiveDate INTEGER NOT NULL DEFAULT 0, -- 本地接收时间，用于缓存版本控制
    receiveOrder INTEGER NOT NULL DEFAULT 0, -- 本地接收时间对应的顺序,
    PRIMARY KEY (sourceId, topicId, listType, listId),
    FOREIGN KEY (sourceId, topicId) REFERENCES Topic(sourceId, id) ON DELETE CASCADE
);

-- 索引迁移
CREATE INDEX IF NOT EXISTS idx_topic_last_key ON Topic(lastReplyAt);
CREATE INDEX IF NOT EXISTS idx_topic_last_access_time ON Topic(lastVisitedAt);
CREATE INDEX IF NOT EXISTS idx_topic_channel_id ON Topic(sourceId, channelId);

CREATE INDEX IF NOT EXISTS idx_listing_query ON TopicListing(sourceId, listType, listId, page);
CREATE INDEX IF NOT EXISTS idx_listing_receive ON TopicListing(sourceId, listType, listId, receiveDate);
CREATE INDEX IF NOT EXISTS idx_listing_order ON TopicListing(sourceId, listType, listId, receiveOrder);

-- 插入 Topic 数据 (仅内容)
upsertTopic:
INSERT INTO Topic (
    id, sourceId, channelId, commentCount, authorId, authorName, title, content, summary,
    agreeCount, disagreeCount, isCollected, createdAt, lastReplyAt
) VALUES ?
ON CONFLICT (sourceId, id) DO UPDATE SET
    channelId = excluded.channelId,
    commentCount = excluded.commentCount,
    authorId = excluded.authorId,
    authorName = excluded.authorName,
    title = COALESCE(excluded.title, Topic.title),
    content = COALESCE(excluded.content, Topic.content), -- 只有当新 content 非空时才更新
    summary = COALESCE(excluded.summary, Topic.summary),
    agreeCount = excluded.agreeCount,
    disagreeCount = excluded.disagreeCount,
    isCollected = excluded.isCollected,
    createdAt = excluded.createdAt,
    lastReplyAt = excluded.lastReplyAt;
    -- lastVisitedAt and lastViewedCommentId are preserved (not updated)

-- 插入 TopicListing 数据
upsertTopicListing:
INSERT INTO TopicListing (
    sourceId, topicId, listType, listId, page, receiveDate, receiveOrder
) VALUES ?
ON CONFLICT (sourceId, topicId, listType, listId) DO UPDATE SET
    page = excluded.page,
    receiveDate = excluded.receiveDate,
    receiveOrder = excluded.receiveOrder;

-- 查询 Topic 数据 (方法名保留原逻辑但改名)
countTopicsByChannelAndPage:
SELECT count(1) FROM TopicListing WHERE sourceId = :sourceId AND listType = 'channel' AND listId = :channelId AND page = :page;

deleteTopicsByChannelAndPage:
DELETE FROM TopicListing WHERE sourceId = :sourceId AND listType = 'channel' AND listId = :channelId AND page = :page;

incrementTopicPage:
UPDATE TopicListing
SET page = page + 1
WHERE sourceId = :sourceId AND listType = 'channel' AND listId = :channelId AND page >= :page;

-- 查询所有 Topic 数据
getAllTopics:
SELECT * FROM Topic;

-- 更新 Topic 数据
updateTopic:
UPDATE Topic SET
    channelId = ?,
    authorId = ?,
    authorName = ?,
    title = ?,
    content = ?,
    summary = ?,
    commentCount = ?,
    agreeCount = ?,
    disagreeCount = ?,
    isCollected = ?,
    createdAt = ?
WHERE sourceId = ? AND id = ?;

-- 仅更新 Topic 详情内容 (用于 Discourse 详情页刷新)
updateTopicContent:
UPDATE Topic SET
    commentCount = ?,
    content = COALESCE(?, content)
WHERE sourceId = ? AND id = ?;

-- 获取特定 Channel 的最大 receiveDate
getMaxReceiveDate:
SELECT MAX(receiveDate) FROM TopicListing WHERE sourceId = :sourceId AND listType = 'channel' AND listId = :channelId;

-- 删除 Topic 数据
deleteTopic:
DELETE FROM Topic WHERE sourceId = ? AND id = ?;

-- 删除 Topic 页的数据
deleteTopicPage:
DELETE FROM TopicListing WHERE sourceId = ? AND listType = 'channel' AND listId = :channelId;

getTopic:
SELECT *
FROM Topic
WHERE Topic.sourceId = :sourceId AND Topic.id = :id;

countTopicsByChannel:
SELECT count(*) FROM TopicListing WHERE sourceId = :sourceId AND listType = 'channel' AND listId = :channelId
AND (
    (:isFallback = 1)
    OR
    (receiveDate = (SELECT MAX(receiveDate) FROM TopicListing WHERE sourceId = :sourceId AND listType = 'channel' AND listId = :channelId))
);

getTopicsInChannel:
SELECT Topic.*
FROM Topic
JOIN TopicListing ON Topic.sourceId = TopicListing.sourceId AND Topic.id = TopicListing.topicId
WHERE TopicListing.sourceId = :sourceId AND TopicListing.listType = 'channel' AND TopicListing.listId = :channelId AND TopicListing.page = :page
ORDER BY Topic.lastReplyAt DESC;

getTopicsByChannel:
SELECT Topic.*
FROM Topic
JOIN TopicListing ON Topic.sourceId = TopicListing.sourceId AND Topic.id = TopicListing.topicId
WHERE TopicListing.sourceId = :sourceId AND TopicListing.listType = 'channel' AND TopicListing.listId = :channelId AND TopicListing.page = :page;

getTopicsInChannelOffset:
SELECT Topic.*
FROM Topic
JOIN TopicListing ON Topic.sourceId = TopicListing.sourceId AND Topic.id = TopicListing.topicId
WHERE TopicListing.sourceId = :sourceId AND TopicListing.listType = 'channel' AND TopicListing.listId = :channelId
ORDER BY Topic.lastReplyAt DESC
LIMIT :limit OFFSET :offset;

getTopicsInChannelKeyset:
SELECT Topic.*, TopicListing.receiveDate, TopicListing.receiveOrder
FROM Topic
JOIN TopicListing ON Topic.sourceId = TopicListing.sourceId AND Topic.id = TopicListing.topicId
WHERE TopicListing.sourceId = :sourceId
  AND TopicListing.listType = 'channel'
  AND TopicListing.listId = :channelId
  AND (
      (:isFallback = 1)
      OR
      (TopicListing.receiveDate = (SELECT MAX(receiveDate) FROM TopicListing WHERE sourceId = :sourceId AND listType = 'channel' AND listId = :channelId))
  )
ORDER BY TopicListing.receiveOrder ASC, TopicListing.topicId DESC
LIMIT :limit OFFSET :offset;

updateTopicLastAccessTime:
UPDATE Topic SET lastVisitedAt = :last_access_time WHERE sourceId = :sourceId AND id = :id;

updateTopicLastReadCommentId:
UPDATE Topic SET lastViewedCommentId = :last_read_comment_id WHERE sourceId = :sourceId AND id = :id;

searchTopics:
SELECT * FROM Topic
WHERE (CAST(id AS TEXT) LIKE ('%' || :query || '%') OR title LIKE ('%' || :query || '%') OR content LIKE ('%' || :query || '%'))
ORDER BY lastReplyAt DESC
LIMIT :limit OFFSET :offset;

countSearchTopics:
SELECT count(*) FROM Topic
WHERE (CAST(id AS TEXT) LIKE ('%' || :query || '%') OR title LIKE ('%' || :query || '%') OR content LIKE ('%' || :query || '%'));

getTopicsByUserHashOffset:
SELECT * FROM Topic
WHERE authorId = :authorId
ORDER BY lastReplyAt DESC
LIMIT :limit OFFSET :offset;

countTopicsByUserHash:
SELECT count(*) FROM Topic WHERE authorId = :authorId;

-- 触发通知 (不实际修改数据)
touchChannelTopics:
UPDATE TopicListing
SET receiveDate = receiveDate
WHERE sourceId = :sourceId AND listType = 'channel' AND listId = :channelId;
